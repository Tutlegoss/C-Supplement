<!DOCTYPE html>
<html>

<head>
	<title>OpPrec vs OrdOfEval</title>
	
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="description" content="">
	
	<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet"> 
	<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet"> 
	<link rel="stylesheet" href="normalize.css">
	<link rel="stylesheet" href="style_blog.css">
	
	<script src="./jquery-3.5.1.min.js"></script>
</head>

<body>
	<div id="content">
		<div class="grid">
			<div id="side">
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
				<p>HI</p>
			</div>
			
			<div id="article">
				<h1>Does Operator Precedence Determine Order of Evaluation?</h1>
				<p class="pre"><!--   
				 -->  Creation Date: 22/JUN/2020
<!--             -->  Edit Date:     22/JUN/2020<!--
			 --></p>
				<br>
				<div class="exBoxYellow">
					<h2>Prerequisites</h2>
					<ul>
						<li>
							Truth tables for <span class="yellow">logical AND (&amp;&amp;)</span> and <span class="yellow">logical OR (||)</span>
						</li>
						<br>
						<li>
							<span class="yellow">PEMDAS</span> or <span class="yellow">BEDMAS</span> - Basic mathematical order of operations
							<ol class="numberedList">
								<li>Parenthesis</li>
								<li>Exponents</li>
								<li>Multiplication/Division</li>
								<li>Addition/Subtraction</li>
							</ol>
						</li>
						<li>
							<span class="yellow">Recall</span>: Whichever operator is furthest left gets evaluated first for 
							Multiplication/Division and Addition/Subtraction<br>[e.g. <span class="co-y">2</span> / 
							<span class="co-y">4</span> * <span class="co-y">5</span> / <span class="co-y">20</span> is parsed as 
							((<span class="co-y">2</span> / <span class="co-y">4</span>) * <span class="co-y">5</span>) / 
							<span class="co-y">20</span>]
						</li>
					</ul>
				</div>
				<br>
				<div class="exBoxCyan">
					<h2>Terms and Definitions</h2>
					<ul>
						<li>
							<span class="cyan">Short-Circuit Evaluation</span> - 
							If the left-hand side of a boolean expression determines the outcome, the right-hand side isn't evaluated
						</li>
						<br>
						<li>
							<span class="cyan">Operator</span> - A symbol or keyword denoting an operation, such as 
							<span class="co-y">+</span> (addition), <span class="co-y">++</span> (prefix increment), 
							<span class="co-y">new</span> (dynamic memory allocation)
						</li>
						<br>
						<li>
							<span class="cyan">Unary Operator</span> - An operator that takes one operand
						</li>
						<br>
						<li>
							<span class="cyan">Binary Operator</span> - An operator that takes two operands
						</li>
						<br>
						<li>
							<span class="cyan">Ternary Operator</span> - An operator that takes three operands
						</li>
						<br>
						<li>
							<span class="cyan">Operand</span> - 
							An argument to an operator 
							<br>(e.g. <span class="co-y">A</span> + <span class="co-y">9</span>; <span class="co-y">A</span> 
							and <span class="co-y">9</span> are operands of the + operator)
						</li>
						<br>
						<li>
							<span class="cyan">Operator Precedence</span> - 
							Levels (that are derived from the grammar) indicating how operators are parsed 
							<br>[e.g. <span class="co-y">x</span> * <span class="co-y">y</span> + <span class="co-y">8</span>; 
							is parsed as (<span class="co-y">x</span> * <span class="co-y">y</span>) + <span class="co-y">8</span>] 
							and operators with a lower precedence level have higher priority (see table below) [compile-time]
						</li>
						<br>
						<li>
							<span class="cyan">Associativity</span> - 
							The direction in which operators are parsed 
							<br>[e.g. <span class="co-y">x</span> = <span class="co-y">y</span> = <span class="co-y">z</span> =
							<span class="co-y">2</span>; 
							is parsed as <span class="co-y">x</span> = (<span class="co-y">y</span> = (<span class="co-y">z</span>
							 = <span class="co-y">2</span>))] since the assignment operator is parsed right-to-left [compile-time]
						</li>
						<br>
						<li>
							<span class="cyan">Order of Evaluation</span> - 
							The sequence that operators' operands/function arguments are processed; 
							There is no specified sequence in C++ <br>(e.g. <span class="co-y">A</span>++ + ++<span class="co-y">B</span>; 
							the compiler can choose either <span class="co-y">A</span>++ or ++<span class="co-y">B</span> 
							to be evaluated first) [runtime]
						</li>
						<br>
						<li>
							<span class="cyan">LHS / lhs</span> - 
							Left-hand side (left operand of operator)
						</li>
						<br>
						<li>
							<span class="cyan">RHS / rhs</span> - 
							Right-hand side (right operand of operator)
						</li>
					</ul>
				</div>
				<br>
				<h2 class="heading">C++ Table of Operator Precedence</h2>
				<p class="p-align">
					First and foremost, we need to see how C++ orders its operators. Below are all the current operators, 
					but visit cppreference.com for complete details at   
					<a href="https://en.cppreference.com/w/cpp/language/operator_precedence">C++ Operator Precedence</a>. 
					Please note: the Three-way comparison, Await-expression, and Yield-expression are only valid with C++20.
					I will not be discussing all of the operators in this article save for the mathematical and logical operators.
				</p>
				<table class="center" id="precTable">
					<thead>
						<tr>
							<th>Precedence</th>
							<th>Operator</th>
							<th>Description</th>
							<th>Associativity</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>1</td>
							<td>::</td>
							<td>Scope resolution</td>
							<td rowspan="2" class="lasc">Left-to-right</td>
						</tr>
						<tr>
							<td>2</td>
							<td>
							    var++ var--<br>
								<em>type</em>() <em>type</em>{}<br>
								function()<br>
								arrayVar[]<br>
								. ->
							</td>
							<td>
							    Suffix/postfix increment and decrement<br>
							    Functional cast<br>
								Function call<br>
								Subscript<br>
								Member access
							</td>
							
						</tr>
						<tr>
							<td>3</td>
							<td>
							    ++var --var<br>
								+var -var<br>
								! ~<br>
								(<em>type</em>)<br>
								*ptr<br>
								&amp;var<br>
								sizeof<br>
								new new[]<br>
								delete delete[]<br>
								co_await
							</td>
							<td>
							    Prefix increment and decrement<br>
								Unary plus and minus<br>
								Logical NOT and bitwise NOT<br>
								C-style cast<br>
								Indirection (dereference)<br>
								Address-of<br>
								Size-of<br>
								Dynamic memory allocation<br>
								Dynamic memory deallocation<br>
								Await-expression
							</td>
							<td class="rasc">Right-to-left</td>
						</tr>
						<tr>
							<td>4</td>
							<td>.* &nbsp; ->*</td>
							<td>Pointer-to-member</td>
							<td rowspan="12" class="lasc">Left-to-right</td>
						</tr>
						<tr>
							<td>5</td>
							<td>
								lhs * rhs<br>
								num / denom<br>
								lhs % rhs
							</td>
							<td>
								Multiplication<br>
								Divsion<br>
								Remainder
							</td>

						</tr>
						<tr>
							<td>6</td>
							<td>
								lhs + rhs<br>
								lhs - rhs
							</td>
							<td>
								Addition<br>
								Subtraction
							</td>
							
						</tr>
						<tr>
							<td>7</td>
							<td>
								&lt;&lt;<br>
								&gt;&gt;
							</td>
							<td>
								Bitwise left shift<br>
								Bitwise right shift
							</td>
		
						</tr>
						<tr>
							<td>8</td>
							<td>&lt;=&gt;</td>
							<td>Three-way comparison</td>
							
						</tr>
						<tr>
							<td>9</td>
							<td>
								&lt; &nbsp; &lt;=<br>
								&gt; &nbsp; &gt;=
							</td>
							<td>
								Relational operators
							</td>
							
						</tr>
						<tr>
							<td>10</td>
							<td>== &nbsp; !=</td>
							<td>Relational operators</td>
							
						</tr>
						<tr>
							<td>11</td>
							<td>&amp;</td>
							<td>Bitwise AND</td>
							
						</tr>
						<tr>
							<td>12</td>
							<td>^</td>
							<td>Bitwise XOR</td>
							
						</tr>
						<tr>
							<td>13</td>
							<td>|</td>
							<td>Bitwise OR</td>
							
						</tr>
						<tr>
							<td>14</td>
							<td>&amp;&amp;</td>
							<td>Logical AND</td>
							
						</tr>
						<tr>
							<td>15</td>
							<td>||</td>
							<td>Logical OR</td>
							
						</tr>
						<tr>
							<td>16</td>
							<td>
							    a ? b : c<br>
								throw<br>
								co_yield<br>
								=<br>
								+= &nbsp; -=<br>
								*= &nbsp; /= &nbsp; %=<br>
								&lt;&lt;= &nbsp; &gt;&gt;=<br>
								&amp;= &nbsp; ^= &nbsp; |=
							</td>
							<td>
							    Ternary conditional<br>
								Throw operator<br>
								Yield-expression<br>
								Direct assignment<br>
								Compound Assignments<br>
								<br>
								<br>
								<br>
							</td>
							<td class="rasc">Right-to-left</td>
						</tr>
						<tr>
							<td>17</td>
							<td>,</td>
							<td>Comma</td>
							<td class="lasc">Left-to-right</td>
						</tr>
					</tbody>
				</table>
				<br>
				<br>
				<h2 class="heading">Four Basic Mathematic Operations</h2>
				<p class="p-align exFont">
					Let's start with something all of us should be familiar with. The four mathematical operations:
					addition, subtraction, multiplication, and division. We know that addition and subtraction
					have the same precedence <span class="co-y">(level 6)</span> and multiplication and division have 
					the same precedence <span class="co-y">(level 5)</span>. Therefore, multiplication and divsion must 
					come before addition and subtraction since the lower the level ensures a higher priority.
					Let's start off with a simple snippet of code:
				</p>
				<div class="exBoxPurple">
					<figure class="code center">
						<pre><table>
<!--                 --><tr>
<!--                     --><td><pre class="co-o">1
<!--                         -->2
<!--                     --></pre></td>
<!--                     --><td class="co-g"><pre><span class="co-c">double</span> x = <span class="co-m">2.0</span>, y = <span class="co-m">4.0</span>, z = <span class="co-m">5.0</span>;
<!--                         -->std::cout &lt;&lt; x <span class="co-y">/</span> y <span class="co-y">+</span> z <span class="co-y">/</span> 20.0;
<!--                         --></pre></td>
<!--                 --></tr></table></pre>
						<p>OUTPUT: 0.75</p>
					</figure>
				</div>
				<p class="p-align exFont">
					The output is 
					<span class="co-m highlight">0.125</span> or 
					<span class="co-m highlight">1/8</span>. Division, multiplication, and addition have left-to-right associativity, so 
					<span class="green highlight">x <span class="co-y">/</span> y</span> are grouped together and 
					<span class="green highlight">z <span class="co-y">/</span> 20.0</span> are grouped together and are both evaluated before addition with a result of 
					<span class="co-m highlight">1/2</span> and
					<span class="co-m highlight">1<span class="co-y">/</span>4</span> respectively. Therefore, our expression can be written as
					<span class="green highlight">(x <span class="co-y">/</span> y) <span class="co-y">+</span> (z <span class="co-y">/</span> 20.0)</span>. We see that the evaluated division expressions 
					become the operands of the addition operator. So, 
					<span class="green highlight">1<span class="co-y">/</span>2 <span class="co-y">+</span> 1<span class="co-y">/</span>4 <span class="co-y">=</span> 3<span class="co-y">/</span>4</span> or 
					<span class="co-m highlight">0.75</span>. This calculates exactly as expected. Now, notice I didn't specify whether 
					<span class="green highlight">x <span class="co-y">/</span> y</span> or 
					<span class="green highlight">z <span class="co-y">/</span> 20.0</span> is evaluated first. If division has left-to-right associativity, then surely
					<span class="green highlight">x <span class="co-y">/</span> y</span> is the logical choice. Well, this may not be the case!
				</p>
				<br>
				<br>
				<h2 class="heading">A Deeper Look at Order of Evaluation</h2>
				<p class="p-align exFont">
					Now, let's look at an example that involves addition where both operands are variables and 
					both operands are incremented.
				</p>
				<div class="exBoxPurple">
					<figure class="code center">
						<pre><table>
<!--                 --><tr>
<!--                     --><td><pre class="co-o">1
<!--                         -->2
<!--                         -->3
<!--                     --></pre></td>
<!--                     --><td class="co-g"><pre><span class="co-c">int</span> lhs = <span class="co-m">1</span>, rhs = <span class="co-m">2</span>;
<!--                         --><span class="co-c">int</span> output = <span class="co-y">++</span>lhs <span class="co-y">+</span> rhs<span class="co-y">++</span>;
<!--                         -->std::cout &lt;&lt; output;
<!--                         --></pre></td>
<!--                 --></tr></table></pre>
						<p>OUTPUT: 4</p>
					</figure>
				</div>
				<p class="p-align exFont">
					So, the postfix increment operator <span class="co-y">(level 2)</span> has a higher priority than the prefix increment operator 
					<span class="co-y">(level 3)</span>. 
					Since the unary operators are separated by addition, our expression can be written as 
					<span class="green highlight">(<span class="co-y">++</span>lhs) 
					<span class="co-y">+</span> (rhs<span class="co-y">++</span>)</span>.
					I have compiled this code snippet down to the assembly version (no optimizations) with 
					<span class="green highlight">g++ (Debian 8.3.0-6) 8.3.0</span>. On a terminal, the command looks like 
					<span class="green highlight">g++ -S program.cpp</span>. This produces a .s file with the same name as your program, 
					so in this case it will produce 
					<span class="green highlight">program.s</span>. 
				</p>
				<ul class="list-tab">
					<li><span class="co-y">Note</span>: The assembly syntax is AT&amp;T, 
						<span class="green highlight">mnemonic source, destination</span>.
					</li>
				</ul>
				<p class="p-align exFont">
					Inspecting this file in a text editor, you'll come across the assembly code below.
					Don't worry if you can't understand assembly as I wrote comments for each line.
				</p>
				<div class="exBoxPurple">
					<figure class="code center mgn-btm">
						<pre><table class="mgn-btm">
<!--                 --><tr>
<!--                     --><td><pre class="co-o">...
<!--                         -->1
<!--                         -->2
<!--                         -->3
<!--                         -->4
<!--                         -->5
<!--                         -->6
<!--                         -->7
<!--                         -->8
<!--                         -->9
<!--                         -->...
<!--                     --></pre></td>
<!--                     --><td class="co-g">
<!--                         --><pre>movl  <span class="co-c">$</span><span class="co-m">1</span>, -<span class="co-m">4</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>    <span class="co-w">/* Assign <span class="co-g">lhs</span> to 1 on the stack */</span>
<!--                         -->movl  <span class="co-c">$</span><span class="co-m">2</span>, -<span class="co-m">8</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>    <span class="co-w">/* Assign <span class="co-g">rhs</span> to 2 on the stack */</span>
<!--                         -->addl  <span class="co-c">$</span><span class="co-m">1</span>, -<span class="co-m">4</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>    <span class="co-w">/* Increment <span class="co-g">lhs</span> */</span>
<!--                         -->movl  -<span class="co-m">8</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>, <span class="co-c">%</span>eax  <span class="co-w">/* Put <span class="co-g">rhs</span> into register eax */</span>
<!--                         -->leal  <span class="co-m">1</span><span class="co-c">(%</span>rax<span class="co-c">)</span>, <span class="co-c">%</span>edx   <span class="co-w">/* Increment register rax (eax) and place result into register edx */</span>
<!--                         -->movl  <span class="co-c">%</span>edx, -<span class="co-m">8</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>  <span class="co-w">/* Store register edx's value into <span class="co-g">rhs</span> on the stack */</span>
<!--                         -->movl  -<span class="co-m">4</span><span class="co-c">(%</span>rbp<span class="co-c">)</span>, <span class="co-c">%</span>edx  <span class="co-w">/* Put <span class="co-g">lhs</span> into register edx */</span>
<!--                         -->addl  <span class="co-c">%</span>edx, <span class="co-c">%</span>eax      <span class="co-w">/* Add registers edx and eax and store result into eax */</span>
<!--                         -->movl  <span class="co-c">%</span>eax, -<span class="co-m">12</span><span class="co-c">(%</span>rbp<span class="co-c">)</span> <span class="co-w">/* Store register eax into <span class="co-g">output</span> on the stack */</span>

<!--                         --></pre></td>
<!--                 --></tr></table></pre>
					</figure>
					<br>
				</div>
				<p class="p-align exFont">
					Look at line 3. The left-hand side was incremented before the right-hand side
					even though the right-hand side has the postfix operator. The right-hand side
					doesn't get incremented and placed back onto the stack until lines 5 and 6 respectively.  
				</p>
				<br>
				<br>
				<h2 class="heading">So, Why Did This Happen?</h2>
				<p class="p-align exFont">
					Essentially, the purpose of operator precedence is to couple operators with operands. 
					Programmers do this when they surround expressions with parenthesis. They want that 
					expression computed first, but there's no guarantee which operand is evaluated first.
					As noted in the Terms and Definitions section, C++ does not have any defined order of evaluation.
					For example, an expression such as 
					<span class="green highlight"><span class="co-y">++</span>x 
					<span class="co-y">-</span> <span class="co-y">++</span>y 
					<span class="co-y">+</span> <span class="co-y">++</span>z</span>
					doesn't guarantee 
					<span class="green highlight"><span class="co-y">++</span>x</span>
					to be evaluated first despite the prefix increment operator being left-to-right associative.
					In fact, 
					<span class="green highlight"><span class="co-y">++</span>x</span>,
					<span class="green highlight"><span class="co-y">++</span>y</span>, or
					<span class="green highlight"><span class="co-y">++</span>z</span> could be evaluated first. However,
					the value of
					<span class="green highlight">(<span class="co-y">++</span>x 
					<span class="co-y">-</span> <span class="co-y">++</span>y)</span> 
					will be computed before being added to the value of 
					<span class="green highlight"><span class="co-y">++</span>z</span> due to the subtraction and 
					addition being on the same precedence level and having left-to-right associativity.
				</p>
				<br>
				<br>
				<h2 class="heading">Okay, Here's A Complex Example</h2>
				<p class="p-align exFont">
					Let's combine several operators and really see operator precedence and associativity at work!
				</p>
				<div class="exBoxPurple">
					<figure class="code center">
						<pre><table>
<!--                 --><tr>
<!--                     --><td><pre class="co-o">1
<!--                         -->2
<!--                         -->3
<!--                         -->4
<!--                         -->5
<!--                     --></pre></td>
<!--                     --><td class="co-g"><pre><span class="co-c">int</span> lhs = <span class="co-m">1</span>, rhs = <span class="co-m">0</span>;
<!--                         --><span class="co-c">int</span> *ptr = <span class="co-y">&amp;</span>lhs;
<!--                         --><span class="co-r">if</span>( lhs <span class="co-y">||</span> <span class="co-y">++*</span>ptr <span class="co-y">&amp;&amp; ++</span>rhs ) {
<!--                         -->    std::cout &lt;&lt; <span class="co-m">&quot;lhs: &quot;</span> &lt;&lt; lhs &lt;&lt; <span class="co-m">&quot;, rhs: &quot;</span> &lt;&lt; rhs;
<!--                         -->}
<!--                         --></pre></td>
<!--                 --></tr></table></pre>
						<p>OUTPUT: lhs: 1, rhs: 0</p>
					</figure>
				</div>
				<p class="p-align exFont">
					Maybe this isn't the output you expect. Let's parse the expression
					<span class="green highlight">lhs <span class="co-y">|| ++*</span>ptr 
					<span class="co-y">&amp;&amp; ++</span>rhs</span> using operator precedence and associativity to
					clarify what associativity really is.
				</p>
				<ul class="exFont list-tab">
					<li><span class="co-y">Level 3</span>: Prefix increment, Dereference (right-to-left)
						<ul>
							<li><span class="green highlight">lhs <span class="co-y">|| </span>
								(<span class="co-y">++</span>(<span class="co-y">*</span>ptr))
								<span class="co-y">&amp;&amp;</span> 
								(<span class="co-y">++</span>rhs)</span>
							</li>
						</ul>
					</li>
				</ul>
				<p class="p-align exFont">
					I want to stress that right-to-left associativity does not mean that 
					<span class="green highlight"><span class="co-y">++</span>rhs</span> 
					is evaluated first. These operators are unary and associativity is important
					if a variable or object contains more than one unary operator. We see that with
					<span class="green highlight"><span class="co-y">++*</span>ptr</span>. Therefore, 
					<span class="green highlight">ptr</span> is dereferenced producing the value stored in 
					<span class="green highlight">lhs</span> followed by incrementing 
					<span class="green highlight">lhs</span>. The dereference operator is further right than
					the prefix increment operator and both of said operators are attached to the same variable.
				</p>
				<ul class="exFont list-tab">
					<li><span class="co-y">Level 14</span>: Logical AND (left-to-right)
						<ul>
							<li><span class="green highlight">lhs <span class="co-y">|| </span>
								((<span class="co-y">++</span>(<span class="co-y">*</span>ptr))
								<span class="co-y">&amp;&amp;</span> 
								(<span class="co-y">++</span>rhs))</span>
							</li>
						</ul>
					</li>
					<li><span class="co-y">Level 15</span>: Logical OR (left-to-right)
						<ul>
							<li><span class="green highlight">(lhs <span class="co-y">|| </span>
								((<span class="co-y">++</span>(<span class="co-y">*</span>ptr))
								<span class="co-y">&amp;&amp;</span> 
								(<span class="co-y">++</span>rhs)))</span>
							</li>
						</ul>
					</li>
				</ul>
				<p class="p-align exFont">
					Take a look at the parenthesis when the logical AND is evaluated. This step makes 
					the logical AND expression the right-hand side of the logical OR expression! We now 
					must recall that logical AND and logical OR use short-circuit evaluation.
					Therefore, if
					<span class="green highlight">lhs</span> evaluates to true, then the right-hand side of the 
					logical OR expression isn't evaluated. In this example, 
					<span class="green highlight">lhs</span> is <span class="highlight co-m">1</span> and <span class="highlight co-m">1</span> equates to true. This is why no variable 
					has a change of state. Even though logical AND has a higher priority, that only means the 
					logical AND operator and its two operands are surrounded by parenthesis resuling in the aforementioned.
				</p>
				<br>
				<br>
				<div class="exBoxGreen">
					<h2>Key Points</h2>
					<ul>
						<li>
							Operator Precedence does not affect Order of Evaluation
						</li>
						<li>
							Operator Precedence determines how the expression will be parsed.
							That is, the higher the priority (the lower the level number) the 
							closer its operands are bound to the operator
						</li>
						<li>
							Unary operators' associativity is used when at least two unary operators are 
							attached to a single operand
						</li>
						<li>
							Binary operators' associativity is used when at least two binary operators are 
							in the same expression
						</li>
					</ul>
				</div>
				<br>
				<br>
			</div> <!-- END ARTICLE -->
		</div>
	</div>
	<footer>
	
	</footer>
	
</body>
</html>

<script>
	$(document).ready(function() {
		$('.lasc').css('color','rgb(245, 239, 66)');
		$('.rasc').css('color','rgb(255, 255, 255)');
	});
</script>